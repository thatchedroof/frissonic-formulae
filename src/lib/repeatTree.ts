// Generated by ChatGPT

// A child can be either a nested RepeatNode or a raw element
export type RepeatChild<T> = RepeatNode<T> | T

export interface RepeatNode<T> {
  children: RepeatChild<T>[]
  count: number // how many times this block repeats
  indices: number[]
}

/**
 * Build a sequence of RepeatNode objects from a flat list of elements.
 * Each node stores a (possibly nested) block plus how many times it repeats.
 */
export function buildRepeatTree<T>(
  seq: T[],
  equals: (a: T, b: T) => boolean = (a, b) => a === b, // default primitive
): RepeatNode<T>[] {
  const n = seq.length

  function compressRange(start: number, end: number): RepeatNode<T>[] {
    const nodes: RepeatNode<T>[] = []
    let i = start

    while (i < end) {
      let bestL = 0
      let bestK = 0
      let bestCover = 0

      for (let L = 1; L <= end - i; L++) {
        const pattern = seq.slice(i, i + L)
        let k = 1

        while (i + L * (k + 1) <= end && arraysEqual(pattern, seq.slice(i + L * k, i + L * (k + 1)), equals)) {
          k++
        }

        if (k > 1) {
          const cover = L * k
          if (cover > bestCover) {
            bestCover = cover
            bestL = L
            bestK = k
          }
        }
      }

      if (bestK > 1) {
        const blockStart = i
        const blockEnd = i + bestL
        const childNodes = compressRange(blockStart, blockEnd)
        nodes.push({ children: childNodes, count: bestK, indices: [] })
        i += bestL * bestK
      } else {
        nodes.push({ children: [seq[i]], count: 1, indices: [] })
        i += 1
      }
    }

    return nodes
  }

  const nodes = compressRange(0, n)
  annotateIndices(nodes)
  console.log('Built repeat tree:', nodes)
  return nodes
}

function arraysEqual<T>(a: T[], b: T[], equals: (x: T, y: T) => boolean): boolean {
  if (a.length !== b.length) return false
  for (let i = 0; i < a.length; i++) {
    if (!equals(a[i], b[i])) return false
  }
  return true
}

export type NodeHit<T> = { type: 'element'; value: T } | { type: 'node'; node: RepeatNode<T> }

/**
 * Computes the total expanded length of a node.
 */
export function measureNode<T>(node: RepeatNode<T>): number {
  let childLength = 0
  for (const c of node.children) {
    if (isNode(c)) childLength += measureNode(c)
    else childLength += 1
  }
  return childLength * node.count
}

/**
 * Find the node or element corresponding to a flat index
 * within an array of root nodes.
 */
export function findAtIndex<T>(nodes: RepeatNode<T>[], index: number): NodeHit<T> | null {
  let pos = index

  for (const node of nodes) {
    const len = measureNode(node)
    if (pos < len) {
      return findInNode(node, pos)
    }
    pos -= len
  }

  return null // index out of range
}

/**
 * Recursive search within a single repeat node.
 */
function findInNode<T>(node: RepeatNode<T>, index: number): NodeHit<T> {
  const childBlockLength = measureNodeOnce(node)
  const relativeIndex = index % childBlockLength

  let pos = relativeIndex

  for (const child of node.children) {
    const len = isNode(child) ? measureNode(child) : 1

    if (pos < len) {
      if (isNode(child)) return findInNode(child, pos)
      return { type: 'element', value: child }
    }
    pos -= len
  }

  // Should never happen
  throw new Error('Index resolution error')
}

/**
 * Measures children only once (not multiplied by count).
 */
function measureNodeOnce<T>(node: RepeatNode<T>): number {
  let sum = 0
  for (const c of node.children) {
    sum += isNode(c) ? measureNode(c) : 1
  }
  return sum
}

function isNode<T>(x: any): x is RepeatNode<T> {
  return x && typeof x === 'object' && 'count' in x && 'children' in x
}

/**
 * After the tree structure is built, fill `indices` for every node.
 * Indices are 0-based positions into the original flat sequence, and include
 * all repetitions implied by `count` and all ancestors.
 */
function annotateIndices<T>(nodes: RepeatNode<T>[]): void {
  const spanCache = new Map<RepeatNode<T>, number>()

  // Number of primitive elements in ONE repetition of this node
  function spanSize(node: RepeatNode<T>): number {
    const cached = spanCache.get(node)
    if (cached !== undefined) return cached

    let size = 0
    for (const child of node.children) {
      if (isRepeatNode(child)) {
        // In one repetition of the parent, the child contributes its own
        // pattern, repeated `child.count` times.
        size += spanSize(child) * child.count
      } else {
        size += 1
      }
    }

    spanCache.set(node, size)
    return size
  }

  function annotateNode(node: RepeatNode<T>, startIndexOfFirstRep: number): void {
    const sizePerRep = spanSize(node)

    // This node's indices: all positions across its `count` repetitions
    for (let r = 0; r < node.count; r++) {
      const base = startIndexOfFirstRep + r * sizePerRep
      for (let j = 0; j < sizePerRep; j++) {
        node.indices.push(base + j)
      }
    }

    // For distributing indices to children, we need the span each child
    // occupies in ONE repetition of the parent.
    const childSpanPerParentRep = node.children.map((child) => {
      if (isRepeatNode(child)) {
        return spanSize(child) * child.count
      } else {
        return 1
      }
    })

    // Now recurse into children for every repetition of this node
    for (let r = 0; r < node.count; r++) {
      let cur = startIndexOfFirstRep + r * sizePerRep

      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i]
        const childSpan = childSpanPerParentRep[i]

        if (isRepeatNode(child)) {
          // Child's own first repetition starts at `cur`
          annotateNode(child, cur)
        }

        cur += childSpan
      }
    }
  }

  // Top-level nodes partition the entire sequence from index 0 upward
  let cur = 0
  for (const node of nodes) {
    annotateNode(node, cur)
    const sizePerRep = spanSize(node)
    cur += sizePerRep * node.count
  }
}

export function isRepeatNode<T>(child: RepeatChild<T>): child is RepeatNode<T> {
  return typeof (child as RepeatNode<T>).count === 'number' && Array.isArray((child as RepeatNode<T>).children)
}

console.log(buildRepeatTree(['A', 'B', 'A', 'B', 'A', 'B', 'C']))
